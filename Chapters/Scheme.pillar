!! Physche: A limited small Scheme

We will start with a limited version of Physche, our small scheme implementation. In this version we will not support the definition new functions. In the second version we will support function definition and in particular closures. 

We start by presentating the subset of Scheme that we will implement.


!!! Scheme in a (super) nutshell
Our objective here is not to write a Scheme following the latest language specification.
 We will just cover a subset. Purists may be not like what I will write but we should take it as a pretext for exploration. I will present only the parts that we will implement. In Physche we do not cover vectors, dotted pairs, continuations, macros.

For a fast yet more complete description of Scheme I like ''Teach yourself Scheme in fixnum days'' by Dorai Sitaram *http://ds26gte.github.io/tyscheme/index.html*.

Here is simple function expressing the length of a list and one example. 


[[[
(define len2 
  (lambda (l)
	(if (null? l)
		0
		(+ 1 (len2 (cdr l))))))
]]]
There is another way to define function but we use this one with explicit use of ==lambda==.

[[[
(len (list 4 1 3 3))
>>> 4
]]]

!!!! S-Expressions
In Scheme, everything is a s-expression. A S-expression can be:
- atomic for booleans (==#t==, ==#f==), number (==1==), symbols (we will treat strings as atomic),
- compound as with lists:  A list starts with the opening parenthesis ==(== and finishes by a closing one ==)==. Lists  also represent procedure application, and
- a procedure:  procedures can be normal (i.e., evaluating all their arguments) or special-forms (i..e, having special ways to evaluate their arguments. This is needed to build control-flow for example).

!!!! Values
We will not present booleans, number and symbols in details but focus on the procedure applications since this is a much more interesting concept. Still there is one important point to raise: the value of an atomic expression is itself. This is important since we will see that the value of list is function application.

[[[
#t 
>>> #t
]]]

[[[
11 
>>> 11
]]]

!!!! Procedure application
Scheme follows a prefixed syntax ==(prog args ...)== where the first element refers to a function and the rest are arguments whose ''values'' is passed to the function. A list represents fonction application.

[[[
(+ (* 3 2) 5)
>>> 30
]]]

The procedure associated with the symbol ==\+== is looked up and the values of the arguments ==(* 3 2)== and ==5== are computed and passed to procedure.

By default the evaluation of a procedure application (a list) evaluates all its components. The procedure returned as value of the first element is applied to the values returned for the rest of the list.

As we saw some procedures evaluate ''all'' their arguments while others should not. 
This is the case for ==define==, ==lambda==, ==quote== and ==if==.
Such procedures are called special-forms and we will have the define their semantics.

!!!! Variable definition
To define  a variable and set  its value, we use ==define== special form: it does not evaluates its first argument and it sets the value of the second argument to symbol represented by the first argument.

[[[
(define pi 3.14)
(define goldenRatio (/ (+ 1 (sqrt 5)) 2))
pi 
>>> 3.14
]]]

!!!! Defining procedure
To define a procedure we use the ==lambda== special form. Its first argument is a list representing the procedure argument and the second argument the body of the procedure. 

[[[
((lambda (x)
	(+ 2 x))
	3)
>>> 5
]]]

Of course we can assign procedure to variable using ==define==.

[[[
(define add2 (lambda (x) (+ 2 x)))
(add2 3)
>>> 5
(add2 33)
>>> 35
]]]

!!!! Quote
==quote== is an interesting special form: it does not evaluate its argument but return it. It is useful when manipulating lists. 

[[[
(quote 1)
>>> 1
]]]

The following expression returns then a list which looks like a function application but it just a list. 
[[[
(quote (quote 1))
>>> (quote 1)
]]]

This operation is so current that it has a special syntax: ==(quote x)== can be written =='x==.
Physche will not support the =='== notation. 

!!!! Program as data
What is particularly interesting is that the syntax of the language is centered on the one of lists and by just using a single quote or the special function ==quote== we can turn a program into its abstract syntax tree.

In the following example we can access the argument of the ==\+== invocation by simple quoting the invocation and accessing using plain list operator such as ==cdr==.

[[[
(cdr (quote (+ 2 3)))
>>> (2 3)
]]]

!!!! List as data
 To manipulate a list we can simply quote it. 

The following primitive procedures allows one to manipulate lists: ==car== (to access the first element), ==cdr== (to access the rest of the list), ==cons== (to create a list) and ==()== represents the empty list. 

[[[
(quote (1 2 3 4))
>>>  (1 2 3 4)
]]]

[[[
(car (quote (1 2 3 4)))
>>> 1
]]]

[[[
(cdr (quote (1 2 3 4)))
>>> (2 3 4)
]]]

[[[
(cons 1 (quote (2 3 4)))
>>> (1 2 3 4)
]]]


!!! Physche's overview

Since we do not want to have to build a full parser, we will bend a bit the syntax of Physche to be compatible with the one of Pharo.
- Booleans will be represented as ==true== and ==false== instead of ==#t== and ==#f==.
- Numbers will be the one of Pharo.
- Symbols and strings will be the ones of Pharo:  ==#pharo== and == 'pharo'==.
- Lists will be represented as arrays to be able to get benefit from the scanner facilities of Pharo as we will explained just after. The empty list is represented by ==#()==.

We are now ready to implement the first version of Physche. 




!! Implementing Physche

We will start to implement a extremely simple parser. Then we will define an interpreter for a limited version of the language.

!!! Simple interpretation architecture

When implementing language compilers, parsing is the process to takes a text as input and produces an abstract representation of the program (see Figure *@naiveChain*). This process is often composed of a scanner and a parser. The scanner cuts the text into a list of tokens. And the parser consumes this list of tokens to build an intermediate representation such as an abstract syntax tree. This abstract syntax tree is then analyzed, annotated, transformed by a compiler to finally generate different code (bytecode or assembly). The generated code embeds the semantics of the implemented language.

+A naive compilation chain.>file://figures/naiveChain.pdf|width=60|label=naiveChain+

Beside having a compiler, we can also have an interpreter, i.e., a program that executes programs of the implemented language. The idea is that the interpreter will consume the intermediate representation and act adequately. For example, when it sees a variable definition, it will declare in a structure (usually an environment) a binding for such variable.

Note that the view depicted in Figure *@naiveChain* is naive in sense the compiler may also emit abstract instructions (for example bytecode) that will be interpreted by an (bytecode) interpreter and may converted on the fly to assembly code. This is what is what the Pharo Virtual Machine is doing.

In our interpreter we will take a simpler route. Since Scheme syntax is simple we will just use a simple scanner and our interpreter will take as input the tokens produced by the scanner. We will use the natural structure of the arrays as simple abstract syntax trees.


!!! Starting
Let us start by defining some tests to drive the development of Psyche's interpreter.

[[[
TestCase subclass: #PhsycheTest
	instanceVariableNames: 'ph'
	classVariableNames: ''
	package: 'Phsyche'
]]]

[[[
PhsycheTest >> setUp
	ph := Phsyche new
]]]

In the following test we see that we use the natural nesting of arrays of Pharo to represent Scheme lists. 

[[[
PhsycheTest >> testParseLambda
	self 
		assert: (ph parse: '(define squared (lambda (x) (* x x)))') 
		equals: #(#define #squared #(#lambda #(#x) #(* x x)))
]]]

Here we check that an empty list is recognised as an empty array. 
[[[
PhsycheTest >> testParseEmptyList
	self assert: (ph parse: '()') equals: #()
]]]

[[[
PhsycheTest >> testParseFloat
	self 
		assert: (ph parse: '12.33')
		equals: 12.33
]]]

[[[
PhsycheTest >> testParseSymbol
	self 
		assert: (ph parse: 'r')
		equals: #r
]]]

[[[
PhsycheTest >> testParseIsNull
	self assert: (ph parse: '(isNull (cons (quote a) #()))') equals: #(#isNull #(#cons #(#quote #a) #())).
	self assert: (ph parse: '(isNull (cons (quote a) ()))') equals: #(#isNull #(#cons #(#quote #a) #()))
]]]


!!! Parsing input text

Now we are ready to implement the ==parse:== method. We create the class Phsyche which is the language interperter.

[[[
Object subclass: #Phsyche
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Phsyche'
]]]

To implement the ==parse:== method we take advantage of the Pharo's ==Scanner== and the fact that we map list to arrays.
Note that this implementation can be really bent and it absoluletely not robust but it serves our teaching purpose.

[[[
Phsyche >> parse: aProgramString
	aProgramString ifEmpty: [ ^ #() ].
	^ (Scanner new scanTokens: aProgramString) first 
]]]

As extension, we suggest to represente lists with pairs as in traditional Lisp and Scheme and to do so to define a better parser.

!!! Evaluating elementary elements

Let us start to specify the expected behavior of the language evaluation.

[[[
PhsycheTest >> testEvalEmptyList
	self assert: (ph eval: (ph parse: '()')) equals: #()
]]]


[[[
PhsycheTest >> testEvalBoolean
	self assert: (ph eval: (ph parse: 'true')) equals: true.
	self assert: (ph eval: (ph parse: 'false')) equals: false.
]]]

[[[
PhsycheTest >> testEvalNumber
	self assert: (ph eval: (ph parse: '12')) equals: 12.
	self assert: (ph eval: (ph parse: '3.14')) equals: 3.14.
]]]


Now we can add the following method to Phsyche

[[[
Phsyche >> eval: expression

	^ expression 
]]]

Quite limited and trivial so far. 


!!! Defining a variable

Now we will add support for the first special form: ==define==. 
We will start with support the definition of variables. 

Here is a test showing the behavior we expect. 
[[[
PhsycheTest >> testEvalExpression
	(ph eval: (ph parse: '(define pi 3.14)')).
	self 
		assert: (ph eval: (ph parse: 'pi'))
		equals:  3.14.
]]]

First we should add a dictionary that will hold the defined variables and their values. 

[[[
Phsyche >> initialize
	super initialize.
	environment := Dictionary new
]]]

[[[
Phsyche >> eval: expression
	expression = #()
		ifTrue: [ ^ expression ].
	expression isSymbol
		ifTrue: [ ^ environment at: expression ].	"returns the variable value"
	expression isArray
		ifFalse: [ "returns literals boolean, string, number" ^ expression ]
		ifTrue: [ | first |
			first := expression first.
			first = #define
				ifTrue: [ ^ environment at: expression second put: (self eval: expression third) ] ]
]]]

The following test shows that the a variable points to a value. 

[[[
PhsycheTest >> testEvalExpression2
	ph eval: (ph parse: '(define pi 3.14)').
	ph eval: (ph parse: '(define pi2 pi)').
	ph eval: (ph parse: '(define pi 6.28)').
	self assert: (ph eval: (ph parse: 'pi2')) equals: 3.14
]]]

!!! Introducing Quote

Quote is an interesting special form. It is the one that does not evaluate its argument.

[[[
PhsycheTest >> testEvalQuote
	self assert: (ph eval: (ph parse: '(quote (* x x))')) equals: #(#* #x #x).
	self assert: (ph eval: (ph parse: '(quote (quote (* x x)))')) equals: #(quote #(#* #x #x))
]]]

[[[
Phsyche >> eval: expression
	expression = #()
		ifTrue: [ ^ expression ].
	expression isSymbol
		ifTrue: [ ^ environment at: expression ].	"returns the variable value"
	expression isArray
		ifFalse: [ "returns literals boolean, string, number" ^ expression ]
		ifTrue: [ | first |
			first := expression first.
			first = #define
				ifTrue: [ ^ environment at: expression second put: (self eval: expression third) ].
			first = #quote
				ifTrue: [ ^ expression second ] ]
]]]



!!! Setting up the primitives

Now will introduce some primitives behavior such as addition, multiplication, list manipulation. In this implementation of Physche we will define them as block closures (a more object-oriented implementation reifying the operations is possible). Let us write a test first to specify what we want to get.

[[[
PhsycheTest >> testEvalExpression
	self assert: (ph eval: (ph parse: '(* 3 8)')) equals: 24
]]]

[[[
PhsycheTest >> testEvalMoreComplexExpression
	self assert: (ph eval: (ph parse: '(* (+ 2 3) 8)')) equals: 40.
	self assert: (ph eval: (ph parse: '(* 8 (+ 2 3))')) equals: 40
]]]

We define then for example the multiplication and addition: 
[[[
Phsyche >> multBinding
	^ #* -> [:e :v | e * v]
]]]

[[[
Phsyche >> plusBinding
	^ #+ ->  [:e :v | e + v]
]]]

The method ==multBinding== is return a pair the primitive name and its associated closures.
The primitive name will be added as a variable in the environement and its value will be the corresponding block.

Now we define the following method to automatically executing all the method ending with 'Binding' to add the primitives to the environment. We take the opportunity to add the primitive name to the list of primitives since it will help use later during the evaluation. 

[[[
Phsyche >> initializeEnvBindings
	(self class selectors select: [ :each | each endsWith: 'Binding' ])
		do: [ :s | 
				| b |
				b := self perform: s. 
				primitives add: b key. 
				environment at: b key put: b value ]
]]]

[[[
Object subclass: #Phsyche
	instanceVariableNames: 'environment primitives'
	classVariableNames: ''
	package: 'Phsyche'
]]]

We redefine the ==initialize== method to initialize the primitive name container and call the ==initializeEnvBindings== method. 

[[[
Phsyche >> initialize
		super initialize.
		environment := Dictionary new. 
		primitives := OrderedCollection new. 
		self initializeEnvBindings 
]]]


Now we should change the ==eval:== method to take into account that we have now to support primitives call. 
What is interesting is that we have to be clear about the semantic of primitive execution, obviously.
We know that we can get the closure associated to the primitive name in the environment,  and a primitive should evaluate all its arguments and pass to the closure. 


[[[
Phsyche >> eval: expression
		expression = #()
			ifTrue: [ ^ expression ].
		expression isSymbol
			ifTrue: [ ^ environment at: expression ].  "returns the variable value"
		expression isArray
			ifFalse: [ "returns literals boolean, string, number" ^ expression ]
			ifTrue: [ | first |
				first := expression first.
				(primitives includes: first)
					ifTrue: [ ^ (environment at: first)
							valueWithPossibleArgs: (expression allButFirst collect: [ :e | self eval: e ]) ]
					ifFalse: [ first = #define
							ifTrue: [ ^ environment at: expression second put: (self eval: expression third) ].
						first = #quote
							ifTrue: [ ^ expression second ] ] ]
]]]


At this point our tests should all pass. 

!!!! Some consideration
Note that for not we consider that the mathematical operations are only working on pairs and not list of elements. We can do this changing the closure application. Another to consider is that explicit check for primitives prevent us to overload locally their definition.


!!!! Some more arithmetic primitives

[[[
Phsyche >> isEqualBinding
	^ #equal -> [ :e :v | e = v ]
]]]

[[[
Phsyche >> greaterOrEqualBinding
	^ #>= -> [ :e :v | e >= v ]
]]]

[[[
Phsyche >> isEqualBinding
	^ #equal -> [ :e :v | e = v ]
]]]

[[[
Phsyche >> minusBinding
	^ #- -> [ :e :v | e - v ]
]]]

[[[
Phsyche >> smallerBinding
	^ #< -> [ :e :v | e < v ]
]]]

[[[
Phsyche >> smallerOrEqualBinding
	^ #< -> [ :e :v | e <= v ]
]]]

!!!! Adding substraction

[[[
Phsyche >> minusBinding
	^ #- -> [ :e :v | e - v ]
]]]


!!!! Adding not 

[[[
PhsycheTest >> testNot
	self assert: (ph eval: (ph parse: '(not false)')).
	self deny: (ph eval: (ph parse: '(not true)'))
]]]

[[[
PhsycheTest >> isNotBinding
	^ #not -> [ :a | a not ]
]]]

!!! Adding list primitives


[[[
PhsycheTest >> testEvalListExpression
	self assert: (ph eval: (ph parse: '(cons (quote a) #())')) equals: #(a)
]]]


[[[
PhsycheTest >> testEvalCarExpressionEvaluatesItsArgument
	self
		assert: (ph eval: (ph parse: '(car (cons (quote a) (cons (quote b) #())))'))
		equals: #a
]]]


[[[
PhsycheTest >> testEvalCdrExpressionEvaluatesItsArgument
	self assert: (ph eval: (ph parse: '(cdr (quote (quote a)))')) equals: #(a)
]]]

[[[
PhsycheTest >> testIsNull
	self assert: (ph eval: (ph parse: '(isNull #())')).
	self deny: (ph eval: (ph parse: '(isNull (cons (quote a) #()))'))
]]]


Here are the primitives definitions. 


[[[
Phsyche >> carBinding
	^ #car -> [ :l | l first ]
]]]

[[[
Phsyche >> cdrBinding
	^ #cdr -> [ :l | l allButFirst ]
]]]

[[[
Phsyche >> consBinding
	^ #cons -> [ :e :l | {e} , l ]
]]]

[[[
Phsyche >> isNullBinding
	^ #isNull -> [ :l | l = #() ]
]]]



!!! Environment and Eval

!! Closures in miniScheme

